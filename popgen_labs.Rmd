---
title: |
  | Next Generation Sequencing Data Formats
  | BZ/MIP 577 Fall 2015
author: Kelly Pierce
output: pdf_document
bibliography: /users/kelly/desktop/library.bib
---

<!--- bibliography: /home/antolinlab/Desktop/library.bib -->

<!--- Set text wrapping for embedded R code -->
```{r set-options, echo=FALSE, }
suppressWarnings(library(knitr))
opts_chunk$set(tidy.opts=list(width.cutoff=60))
```

<!--- Most of the old stuff was a bit beyond the scope of the course, so I've streamlined it a bit -->

# Next generation sequencing (NGS) data can be used to address many biological questions

Next-generation sequencing commonly refers to a set of DNA sequencing platforms that perform *short-read* sequencing. These platforms are multiplexed and high-throughput -- they can simultaneously sequence 100s of individuals and produce 100s of millions of reads. This DNA sequence data are then used to identify variants within populations. We can detect single nucleotide polymorphisms (SNPs), insertion/deletions, and larger scale genomic variation like inversions and chromosome duplications using NGS data.

There are a number of biological questions addressed with NGS data, and a number of sequencing platforms for gathering those data. Instead of attempting to cover the breadth of these technologies and applications, our labs will focus only on population genetics questions answered with sequences obtained from the Illumina HiSeq platform. Subsequent labs will specifically address the analyses listed in bold below.

Population genetics analysis of NGS data:

  - **detect population structure**
  - **test for selection vs. drift**
  - infer migration rates
  - genome-wide association studies

# Assembling NGS data: filtering signal from noise

Inferring true sequence identity from the NGS data delivered is a rich area of research. NGS studies produce very large data sets, in part because each piece of DNA must be read several times to increase certainty about the nucleotide sequence. Bioinformaticians develop algorithms to handle the massive quantities of data generated by NGS projects. This work typically requires a supercomputer. Small datasets can be handled by personal computers, albeit slowly. You will be working with data that has already been processed through the appropriate bioinformatic pipeline to remove sequence errors and determine genotypes. 

## Paired-end Illumina NGS Data for Reduced-Representation Sequencing

While you will be provided with assembled NGS data, it is important to have a bit of context for how the DNA sequences were obtained. The NGS data we are working with in this class is from Illumina HiSeq Paired-End reads (read = one stretch of DNA sequence data, in this case 100bp). These the reads were made from a reduced-representation library. This means we do not have sequence data for the entire genome, but instead have sequence data from a sample of spots distributed across the genome. 

Reduced-representation sequencing is fundamentally different from whole-genome resequencing, which uses NGS technology to sequence the entire genome of every individual in the study population. Whole-genome resequencing is useful for detecting variation at all scales, from SNPs to inversions and chromosome duplications. In contrast, the short and sparse reads obtained from reduced-representation sequencing are best suited for identifing only SNPs. Despite this drawback, reduced-representation sequencing is a cost-effective way to study large populations. As sequencing prices decrease, population genetics research is expected to shift away from using reduced-representation sequence data in favor of whole-genome resequencing data. But for now, reduced-representation techniques are widely used in population genetics.

![paired-end](/Users/Kelly/Desktop/CSU_PopGen_Labs/PairedEndSchematic_NoTitle.png)

*Figure 1. Relationship between genome and sequence data derived through Illumina paired-end sequencing. Only the ends of DNA fragments that are within a certain size range are sequenced. This produces a **reduced-representation** of the genome.*

## Raw sequence data files use FASTQ format

FASTQ files are text files with four lines for each sequence read:

```
@HWI-D00289:185:C6FE5ANXX:8:1101:1178:2176 1:N:0:ACTTGA
AACTACATGTTCTTCAAATATACTTAGTTGGTCTTTCCAACATTCTCCAA
+
</</<<FFFFFFFFFFFFFBF<FFFFFFFF/F<FFFFFFFFFFFBFFF/<
```

These lines contain the following information:

**Line 1:**

\@Instrument:RunNumber:FlowcellID:Lane:Tile:x-coord:y-coord Read:IsFiltered:ControlNo:SampleID

Fields in the first line with paying attention to:

"Read" indicates if the sequence is read 1 or read 2 in a paired end run. Read 1 and Read 2 will likely be delivered to you in separate files by your sequencing facility. If not, use this field to separate them.

"Sample ID" will be either a number or an Illumina barcode sequence. This indicates the library and *NOT* the individual sample ID.

For more information, see the Illumina data format specification: http://support.illumina.com/content/dam/illumina-support/help/BaseSpaceHelp_v2/Content/Vault/Informatics/Sequencing_Analysis/BS/swSEQ_mBS_FASTQFiles.htm

**Line 2:** DNA sequence. 

**Line 3:** Spacer.

**Line 4:** Illumina quality score: http://www.illumina.com/documents/products/technotes/technote_understanding_quality_scores.pdf

This information may be used by your assembly software to filter out low quality sequences.

# Assembled genotype variant data are stored in the Variant Call Format (VCF)

You will be working today with Variant Call Format data, which is produced from assembling the raw sequence data found in FASTQ files.

The Variant Call Format is a flexible text data structure that can accommodate sequence data from a diversity of project. VCF files include sample IDs, sample genotypes at sequenced loci, genotype quality scores, and additional information as desired by the researcher.

![VCF](/Users/Kelly/Desktop/CSU_PopGen_Labs/vcf_format.png)
*Figure 2. Variant Call Format. If you have a VCF file small enough to open in a regular text editor (e.g., Notepad, TextEdit, TextWrangler), it will look like this.*

## You cannot analyze an NGS dataset from start to finish in R!

The raw datasets are too large. The VCF file you'll be working with was generated from a 75Gb FASTQ file. The original assembly VCF file is 2.8Gb, which is still too large to load into R. After quality filtering, the final VCF file is 4.8Mb -- this is a managable size! Processing the data to produce this final file took hours on computing clusters, and this is a relatively **small** NGS data set.

We will work directly with assembled and variant-called NGS data in a VCF file. There are a multitude of R packages that can load VCF files and manipulate them. We will use one particularly user-friendly R package for VCF files, "VariantAnnotation," to explore the contents of a VCF file containing SNP data from ticks.

Many R packages require different input formats, which means your VCF files may need to be converted to other file types. In subsequent labs you will be given the data you need for exercises in the proper format.

<!--- A bit of reformatting work to get the VCF file compatible with VariantAnnotation -->

```{r VCF-format, echo=FALSE, eval=FALSE}
# reformatting the VCF file so each locus is on "chrom 1"
# read in the VCF file as a regular table to get some quick info...
tick.table<-read.table('~/Dropbox/ddRADseq/Final_Analysis/Structure_by_Site/Final_Pseudoref_minmeanDP20_minGQ25_maf0.05_BOTH_SITES_host_filtered_only_maxmissing0.75_MERGED.vcf', sep="\t", header=T, comment.char="")

# make it appear as though all those snps are on the same chromosome for VariantAnnotation compatibility
tick.table[,1]<-rep('1', length(tick.table[,1]))

# fix the names
names(tick.table)[1]<-"#CHROM"

# write the output file
write.table(tick.table, '~/Desktop/CSU_PopGen_Labs/Data/chrom1_tick_dummy_data.vcf', quote=FALSE, row.names=FALSE, sep="\t")
```
<!--- some command line things to index the newly created VCF file

# retrieve the header for the VCF file... opening it partially in gedit allows us to scroll down and see the first 417,187 lines are header. put those in a new file. (we're using data I processed through my merge_vcf.r script, which removes the header)
$ cd ~/Desktop/D_variabilis_Pseudoref/MasterPseudoRefVCF_Copy/
$ head -417187 pseudoref_mapped_genotypes.vcf >> pseudoref_vcf_header.txt
$ cp pseudoref_vcf_header.txt ~/Desktop/CSU_PopGen_Labs/

# paste the header onto the filtered data file we're using
$ cd ~/Desktop/CSU_PopGen_Labs/
$ cat pseudoref_vcf_header.txt chrom1_tick_dummy_data.vcf >> full_chrom1_tick_dummy_data.vcf

# index the full VCF file
$ sudo apt-get install tabix
$ bgzip full_chrom1_tick_dummy_data.vcf
$ tabix -f full_chrom1_tick_dummy_data.vcf.gz
-->


```{r read-data-silent, echo=FALSE, cache=TRUE, results='hide'}
# read everything in with file paths properly formatted, but don't display code
# subsequent code blocks to load data are for display only (not executed)
setwd('~/Desktop/CSU_PopGen_Labs')
tick.vcf<-suppressWarnings(readVcf('Data/tick_snps.vcf.gz', character('1')))
```

\pagebreak

# Exercises

## Dataset
You will be working with a dataset in VCF format that describes SNP variation in American dog ticks (*Dermacentor variabilis*). These ticks carry wildlife pathogens and feed on a large diversity of wildlife host species. The ticks were collected directly from host animals at two different locations in Texas to address questions about how genotype correlates with collection site and host species. You will work with these data in subsequent exercises as well.

## Instructions
Complete the following steps in R. Your end result should be a script that loads the requisite packages and walks through the analyses described. Write answers to specific questions in the comments of your code.

Load the VariantAnnotation R package, which is available through BioConductor. Simply copy and paste the following lines into your script. You will only need to run these commands once to install the package. 

```{r install-pkgs, eval=FALSE}
# utility just for reading VCF files into R
source("http://bioconductor.org/biocLite.R")
biocLite("VariantAnnotation")
```

Once the package is installed, you can load the package to access its functions:

```{r load-pkg-silent, eval=TRUE, include=FALSE}
library(VariantAnnotation)
```

```{r load-pkg, eval=FALSE, echo=TRUE}
library(VariantAnnotation)
```

####1. Download and load the data.

Download the data from here:
```
/Dropbox/BZ 577/Week 4/tick_snps.vcf.gz
```
and save in your prefered directory.

You **cannot** load this dataset using the GUI interface in R/R Studio/R Commander. You will have to use the *readVcf()* function in the VariantAnnotation package. You will therefore either need to provide the full file path to where you have saved the data or use the *setwd()* function to set your working directory. Your working directory is the directory (folder) where R will look for any data you try to open using functions. It is also the directory to which any output files, such as figures, will save unless otherwise specified.

Note that the structure of the file paths for Mac and Windows are different.

**Working directory example (Mac)** 

```{r setwd-example, eval=FALSE}
setwd('/Users/Kelly//Dropbox/BZ 577/Week 4/') # set the working directory
getwd() # print the  working directory
```

**Working directory example (Windows)**

```{r setwd-pc-ex, eval=FALSE}
setwd("C:/Documents and Settings/Data")
getwd() # print the working directory
```

```{r include=FALSE}
# put the working dir back to the correct value
setwd('~/Desktop/CSU_PopGen_Labs')
```

Once the data are loaded, use the *str()* function to look at the structure of the VCF data object.


```{r read-data, eval=FALSE}
# import the VCF file
tick.vcf<-suppressWarnings(readVcf('tick_snps.vcf.gz', character('1')))
# look a the data structure
str(tick.vcf)
```


Yikes! That a complicated data structure -- do not worry about fully understanding all the components. Just understand that this level of detail is necessary to fully represent all the data contained in the VCF file. Not all VCF files have information in all of these slots -- different sequencing studies will generate different types of data. The VCF file can handle all the different types of data, but at the cost of being a complicated format!

####2. Access contents of the VCF object.

The VCF file you loaded is read in as a "VCF object." This is a different data type from others you have used (vectors, data frames, and matrices). Accessing the information in the VCF object requires the use of special functions in the VariantAnnotation package. Explore the data using the functions below.

Refer back to *Figure 2*, which shows the raw text structure of a VCF file. Note how these R functions access the different components of the VCF file.

```{r explore-VCF, eval=TRUE, results='hide'}
# these are the names of the columns in the header
info(header(tick.vcf))

# geno() returns the codes listed FORMAT column of the VCF file
geno(tick.vcf)

# geno(header()) returns the definitions of those codes
geno(header(tick.vcf))

# return the sample names
samples(header(tick.vcf))

```

####3. Assess genotype quality.

Genotype quality is an important metric used to decide if we believe SNPs are the result of sequencing error or meaninful variation. VCF files report Phred-like quality scores. These are integers calculated as *-10 log (p)*, where *p* is the probability of an error. Lower values of *p* produce higher quality scores; high variant call quality means high confidence that the variation is real. 

Use the *qual()* function to look at the quality scores in the dataset, and use the *min()* and *max()* functions to determine the minimum and maximum quality scores observed. 
  
<!--- explanation of qual 999: https://genegrid.genomatix.com/grid/doc/help/faq -->

```{r qual-VCF, eval=FALSE}
# qual() returns the quality scores for the SNPs
qual(tick.vcf)

# what are the minimum and maximum quality scores?
min(qual(tick.vcf))
max(qual(tick.vcf))
```
  
####4. Visualize the quality scores.

Use the *hist()* function to look at the distribution of quality scores. Label the axes of your histogram appropriately (see *?hist()* for more details on how to format your histogram). Describe the distribution you see.

\pagebreak

####5. Relate quality scores to probability of genotyping error

Understand how quality scores related to probabilistic uncertainty in genotype calls by converting quality scores to p(genotype error). Replicate the code below. What is the highest p(genotyping error) in the dataset?

```{r pval-VCF, eval=TRUE, results='hide'}
# compare quality score to probability of genotyping error
# use this function to convert quality to p(error)
qual.to.p<-function(quality){
  p=10^(quality/-10)
  return(p)
}

p=qual.to.p(qual(tick.vcf))

max(p)
```  

####6. Check that all variations are single nucleotide variations.

VCF files can contain indel and structural variants as well. We expect all of our data, however, to be SNP data. It is important to check that your data are what you expect. Use the *isSNV()* function to confirm that all the data are single nucleotide variants.

```{r check-SNP, results='hide'}
# are all the data SNPs with one alt. allele?
isSNP<-isSNV(tick.vcf)
length(isSNP[which(isSNP==F)])
```

####7. Look at the reference and alternative alleles.

Use the *ref()* and *alt()* functions to look at the reference and alternative alleles for each variant.

```{r ref-alt, eval=FALSE, echo=FALSE}

# for each variant, what are the reference and alternative alleles?
ref(tick.vcf)
alt(tick.vcf)
```

####8. Count transitions and transversions.

If all the variants are SNPs with only a single alternative allele, we can easily count transitions and transversions in our dataset. Use the *isTransition()* function to determine the type of mutation that produced each SNP.

There is not function to directly look for transversions, but if a SNP with only one alternative allele is **not** a transition, it must be a transversion.

```{r mutation-type, results='hide'}
isTransit<-isTransition(tick.vcf)

n.Transit<-length(isTransit[which(isTransit==T)]); n.Transit

n.Transver<-length(isTransit[which(isTransit==F)]); n.Transver
```

####9. Visualize transition and transversion counts.

Counts are often visualized using barplots or pie charts. Use the *pie()* and *barplot()* functions to visualize the transitions and transversions counts. Which plot style do you feel best conveys the information?

```{r vis-mutation, eval=FALSE, echo=FALSE}
pie(c(n.Transit, n.Transver), labels=c('Transition', 'Transversion'), col=c('white', 'gray'))
```

\pagebreak

# Summary of functions used

Functions in the *base* library are functions that are installed and automatically loaded in R. Functions in other libraries will need to be loaded before use. Consult the help documentation for each function for further information.

## Functions for loading libraries

|Function|Library|Use|
|:-------|:------------|:---|
|source()|base|load code from saved file|
|library()|base|load code from installed package|
|biocLite()|BiocInstaller|load BioConductor code|

## Functions for controlling output

|Function|Library|
|:-------|:------------|:---|
|suppressWarnings()|base|prevents warnings from printing to screen (use with caution)|

## Functions for loading data

|Function|Library|Use|
|:-------|:------------|:---|
|setwd()|base|set working directory|
|readVcf()|VariantAnnotation|read a VCF file|

## Functions for accessing data
|Function|Library|Use|
|:-------|:------------|:---|
|str()|base|look at data structure|
|which()|base|logical test for equivalence|
|length()|base|returns length of object|
|min()|base|returns minimum value of data|
|max()|base|returns maximum value of data|
|hist()|base|plots histogram|
|pie()|base|plots pie chart|
|barplot()|base|plots barplot|
|info()|VariantAnnotation|returns info on VCF object|
|header()|VariantAnnotation|returns header of VCF object|
|geno()|VariantAnnotation|returns names of data types in VCF object format column|
|samples()|VariantAnnotation|returns sample names in VCF object|
|qual()|VariantAnnotation|returns quality scores in VCF object|
|ref()|VariantAnnotation|returns reference allele in VCF object|
|alt()|VariantAnnotation|returns alternative allele in VCF object|
|isSNV()|VariantAnnotation|returns logical (is single nucleotide variation?) in VCF object|
|isTransition()|VariantAnnotation|returns logical (is transition?) in VCF object|
